/*
 * Copyright 2013 UNAVCO, 6350 Nautilus Drive, Boulder, CO 80301
 * http://www.unavco.org
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
 * General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * 
 */

package org.gsac.gsl.output.file;



import org.gsac.gsl.*;
import org.gsac.gsl.model.*;
import org.gsac.gsl.output.*;
import org.gsac.gsl.util.*;

import java.io.*;


import java.util.List;
import java.util.Date;
import java.text.SimpleDateFormat;

import javax.servlet.*;
import javax.servlet.http.*;


/**
 * Class description
 *
 *
 * @version        Enter version here...
 * @author         J McWhirter, May 19, 2010.
 * @author         SK Wier Nov 15, 2013  add new useful items: start and stop time of data, and MD5 check sum to verify downloads
 */
public class CsvFileOutputHandler extends StreamingOutputHandler {

    /** date formatter  note NO "T", and we do not know if it is UTC time or what.*/
    /* somehow the Z here results in a value like "2001-07-11 00:00:00 -0600" with no Z */
    private SimpleDateFormat dateTimeFormatnoT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");


    /** output id */
    public static final String OUTPUT_FILE_CSV = "file.csv";


    /**
     * _more_
     *
     * @param gsacRepository _more_
     * @param resourceClass _more_
     */
    public CsvFileOutputHandler(GsacRepository gsacRepository,
                                ResourceClass resourceClass) {
        super(gsacRepository, resourceClass);
        getRepository().addOutput(getResourceClass(),
                                  new GsacOutput(this, OUTPUT_FILE_CSV,
                                      "File CSV", "/files.csv", true));
    }


    /**
     * _more_
     *
     * @param response The response
     * @param resource _more_
     */
    public void processResource(GsacResponse response,
                                GsacResource resource) {
        try {
            GsacFile file = (GsacFile) resource;
            FileInfo fi   = file.getFileInfo();
            //Its OK to do this every time because the response keeps track if it has started already
            boolean firstTime = !response.getHaveInitialized();
            response.startResponse(GsacResponse.MIME_CSV);

            PrintWriter pw = response.getPrintWriter();
            if (firstTime) {
                //pw.print("#Id, Type, Md5, FileSize, PublishDate, Url\n");
                // new for standard csv format header 15 Nov 2103
                pw.print("#fields=Id[type='string'],Type[type='string'],MD5[type='string'],FileSize,PublishDate[type='date'],URL[type='string'],start_time[type='date' format='yyyy-MM-ddTHH:mm:ss'],stop_time[type='date' format='yyyy-MM-ddTHH:mm:ss'],sample_interval\n");

                pw.append(  "#   Generated by "+ getRepository().getRepositoryName()  + " on "+ myFormatDateTime(new Date()) + " \n");
            }
            String id = file.getId();
            if (getRepository().isRemoteResource(file)) {
                String[] pair = getRepository().decodeRemoteId(id);
                id = pair[0] + ":" + pair[1];
            }
            pw.print(id + ",");
            pw.print(file.getType().getLabel() + ",");
            pw.print(fi.getMd5() + ",");
            pw.print(fi.getFileSize() + ",");
            // TODO: Apparently the publish date does not include mm:ss
            //Date date = file.getPublishDate();
            //SimpleDateFormat sdf = makeDateFormat("yyyy-MM-dd'T'HH:mm:ssz");
            //pw.print( sdf.format(date) + "," );
            pw.print(file.getPublishDate() + ",");

            //List<GsacResource> relatedResources = file.getRelatedResources();
            //if (relatedResources.size() == 1) {
            //    pw.print(relatedResources.get(0).getId());
            //} else {
            //    
            // }

            // has \n for end of line
            //pw.print(fi.getUrl().replace("\\s+$", "") + "\n");

            // new times in output 15 Nov 2103
            pw.print  (fi.getUrl().replace("\\s+$", "") +","  );

            Date startTime   = resource.getFromDate();
            Date endTime     = resource.getToDate();
            String start = " ";
            String end = " ";
            //String publish = " ";
            SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            //if (publishTime != null) {
            //    publish = sdfDate.format(publishTime);
            //}
            if (startTime == null && endTime != null) {
                   end = sdfDate.format(endTime);
                   pw.print  (","+end  );
            }
            else if (endTime == null && startTime != null) {
                   start = sdfDate.format(startTime);
                   pw.print  (start+","  );
            }
            else {
                   // case of prototype gsac code has proper times: 
                   start = sdfDate.format(startTime);
                   end = sdfDate.format(endTime);
                   pw.print  (start+","+end  );
            }

            //if ( resource.getFileInfo().getSampleInterval() > 0) {
            if ( fi.getSampleInterval() > 0) {
                    pw.print( "," +  (""+ fi.getSampleInterval()) ); // no final ',' at proper end of complete line
            } else {
               pw.print  (","  );
            }

            pw.print  ("\n");

        } catch (Exception exc) {
            throw new RuntimeException(exc);
        }
    }


  /**
     * _more_
     *
     * @param date _more_
     *
     * @return _more_
     */
    private String myFormatDateTime(Date date) {
        if (date == null) { return ""; }
        synchronized (dateTimeFormatnoT) {
            return dateTimeFormatnoT.format(date);
        }
    }

}
